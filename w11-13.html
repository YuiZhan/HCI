import { Component, OnInit, signal, computed, effect } from '@angular/core';
import { CommonModule } from '@angular/common';

// å®šç¾©é£Ÿç‰©è³‡æ–™ä»‹é¢
interface Food {
  name: string;
  enName: string;
  emoji: string;
  desc: string;
}

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="app-container">
      <!-- Agent: The Soul of the App -->
      <div class="agent-container">
        <div class="agent-avatar">ğŸ‘©â€ğŸ³</div>
        <div class="agent-bubble" [class.pop]="agentPop()">
          {{ agentText() }}
        </div>
      </div>

      <!-- Main Interaction Area -->
      @if (!champion) {
        <div class="arena">
          <!-- Left Card -->
          <div class="food-card" 
               [class.winner-anim]="animState === 'left-win'"
               [class.loser-anim]="animState === 'right-win'"
               (click)="selectWinner('left')"
               (mouseenter)="onHover('left')">
            <div class="card-bg-effect"></div>
            
            <!-- Food Image / Fallback Emoji -->
            <div class="food-image-wrapper">
              @if (!hasImageError(currentLeft().name)) {
                <img [src]="getImageUrl(currentLeft())" 
                     class="food-image" 
                     alt="{{currentLeft().name}}"
                     (error)="handleImageError(currentLeft().name)"
                     loading="eager">
              } @else {
                <div class="emoji-fallback">{{ currentLeft().emoji }}</div>
              }
            </div>
            
            <div class="food-name">{{ currentLeft().name }}</div>
          </div>

          <!-- Right Card -->
          <div class="food-card" 
               [class.winner-anim]="animState === 'right-win'"
               [class.loser-anim]="animState === 'left-win'"
               (click)="selectWinner('right')"
               (mouseenter)="onHover('right')">
            <div class="card-bg-effect"></div>
            
            <!-- Food Image / Fallback Emoji -->
            <div class="food-image-wrapper">
              @if (!hasImageError(currentRight().name)) {
                <img [src]="getImageUrl(currentRight())" 
                     class="food-image" 
                     alt="{{currentRight().name}}"
                     (error)="handleImageError(currentRight().name)"
                     loading="eager">
              } @else {
                <div class="emoji-fallback">{{ currentRight().emoji }}</div>
              }
            </div>

            <div class="food-name">{{ currentRight().name }}</div>
          </div>
        </div>

        <!-- Progress & Context -->
        <div class="progress-container">
          <div class="round-info">{{ roundName() }}</div>
          <div class="progress-dots">
            @for (dot of dotsArray; track $index) {
              <div class="dot" [class.active]="$index <= currentPairIndex() / 2"></div>
            }
          </div>
        </div>
      }

      <!-- Champion Display -->
      @if (champion) {
        <div class="champion-screen">
          <h1 class="champion-title">ğŸ† å°ç£ç¾é£Ÿå† è» ğŸ†</h1>
          
          <div class="champion-image-wrapper">
             @if (!hasImageError(champion!.name)) {
               <img [src]="getImageUrl(champion!)" 
                    class="food-image" 
                    alt="Champion"
                    (error)="handleImageError(champion!.name)">
             } @else {
               <div class="emoji-fallback big">{{ champion!.emoji }}</div>
             }
          </div>
          
          <h2 class="champion-name">{{ champion?.name }}</h2>
          <button class="btn-restart" (click)="restartGame()">å†ç©ä¸€æ¬¡ (è‚šå­é¤“äº†)</button>
        </div>
      }
    </div>
  `,
  styles: [`
    /* Import Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');

    :host {
      --primary-color: #ff6b6b;
      --secondary-color: #feca57;
      --bg-color: #ffeaa7;
      --text-color: #2d3436;
      
      display: block;
      font-family: 'Noto Sans TC', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      overflow: hidden;
    }

    .app-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    /* --- Agent Section --- */
    .agent-container {
      position: absolute;
      top: 5%;
      width: 90%;
      max-width: 600px;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    .agent-avatar {
      font-size: 4rem;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
      animation: float 3s ease-in-out infinite;
    }

    .agent-bubble {
      background: white;
      padding: 15px 25px;
      border-radius: 30px;
      border: 4px solid var(--primary-color);
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--primary-color);
      box-shadow: 0 10px 20px rgba(0,0,0,0.15);
      margin-top: 10px;
      position: relative;
      transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    
    .agent-bubble.pop {
      transform: scale(1.05);
    }

    .agent-bubble::after {
      content: '';
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 0 10px 10px;
      border-style: solid;
      border-color: transparent transparent var(--primary-color);
    }

    /* --- Battle Arena --- */
    .arena {
      display: flex;
      width: 100%;
      height: 60%;
      align-items: center;
      justify-content: center;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }

    .food-card {
      flex: 1;
      max-width: 400px;
      height: 100%;
      background: white;
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      transition: transform 0.2s;
      overflow: hidden;
      user-select: none;
    }

    /* Image Wrapper & Fallback */
    .food-image-wrapper {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      overflow: hidden;
      border: 5px solid white;
      box-shadow: 0 8px 16px rgba(0,0,0,0.15);
      z-index: 2;
      transition: transform 0.2s;
      background-color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .food-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .emoji-fallback {
      font-size: 5rem;
      line-height: 1;
    }
    
    .emoji-fallback.big {
      font-size: 8rem;
    }

    .food-name {
      font-size: 1.5rem;
      font-weight: 900;
      margin-top: 25px;
      z-index: 2;
      text-align: center;
    }

    @media (min-width: 768px) {
      .food-image-wrapper { width: 220px; height: 220px; }
      .food-name { font-size: 2rem; }
      .emoji-fallback { font-size: 7rem; }
    }

    .card-bg-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, var(--secondary-color) 0%, transparent 70%);
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1;
    }

    /* Hover Effects */
    @media (hover: hover) {
      .food-card:hover {
        transform: scale(1.05);
        box-shadow: 0 20px 40px rgba(0,0,0,0.2);
      }
      .food-card:hover .food-image-wrapper {
        animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both infinite; 
      }
      .food-card:hover .card-bg-effect {
        opacity: 0.5;
      }
    }

    /* Animations */
    .winner-anim {
      animation: zoomAndGlow 0.8s forwards !important;
      z-index: 10;
    }

    .loser-anim {
      animation: explodeAndFade 0.8s forwards !important;
      pointer-events: none;
    }

    /* --- Progress --- */
    .progress-container {
      position: absolute;
      bottom: 5%;
      width: 80%;
      text-align: center;
    }

    .round-info {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 10px;
      color: #636e72;
    }

    .progress-dots {
      display: flex;
      justify-content: center;
      gap: 5px;
    }

    .dot {
      width: 10px;
      height: 10px;
      background-color: #dfe6e9;
      border-radius: 50%;
    }

    .dot.active {
      background-color: var(--primary-color);
    }

    /* --- Champion Screen --- */
    .champion-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      animation: popIn 0.5s ease-out;
      text-align: center;
    }

    .champion-title {
      color: var(--primary-color);
      font-size: 2.5rem;
      margin-bottom: 0;
    }

    .champion-image-wrapper {
      width: 250px;
      height: 250px;
      border-radius: 50%;
      overflow: hidden;
      border: 8px solid white;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      margin: 30px 0;
      animation: spin 20s linear infinite; /* Slower spin for photo */
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .champion-name {
      font-size: 2rem;
      margin-bottom: 30px;
    }

    .btn-restart {
      padding: 15px 40px;
      font-size: 1.5rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
      transition: transform 0.1s;
      font-family: inherit;
      font-weight: bold;
    }
    .btn-restart:active { transform: scale(0.95); }

    /* Keyframes */
    @keyframes shake {
      10%, 90% { transform: translate3d(-1px, 0, 0) scale(1.1); }
      20%, 80% { transform: translate3d(2px, 0, 0) scale(1.1); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0) scale(1.1); }
      40%, 60% { transform: translate3d(4px, 0, 0) scale(1.1); }
    }
    @keyframes zoomAndGlow {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); background-color: #ffeaa7; }
      100% { transform: scale(1); background-color: white; }
    }
    @keyframes explodeAndFade {
      0% { transform: scale(1); opacity: 1; filter: blur(0px); }
      50% { transform: scale(0.8) rotate(10deg); opacity: 0.5; filter: blur(4px); }
      100% { transform: scale(0) rotate(20deg); opacity: 0; filter: blur(10px); }
    }
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    @keyframes popIn {
      0% { transform: scale(0); }
      80% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
  `]
})
export class App implements OnInit {
  // --- Data ---
  // Simplified: we only need name, enName, emoji, desc
  // searchTerms removed as we use direct name search now
  readonly allFoods: Food[] = [
    { name: "æ»·è‚‰é£¯", enName: "Braised Pork Rice", emoji: "ğŸš", desc: "è‚¥ç˜¦ç›¸é–“ï¼Œå…¥å£å³åŒ–ï¼" },
    { name: "çç å¥¶èŒ¶", enName: "Bubble Tea", emoji: "ğŸ§‹", desc: "å°ç£ä¹‹å…‰ï¼ŒQå½ˆæœ‰å‹ï¼" },
    { name: "è‡­è±†è…", enName: "Stinky Tofu", emoji: "ğŸ˜¤", desc: "è¶Šè‡­è¶Šé¦™ï¼Œå¤–é…¥å…§å«©ï¼" },
    { name: "é›æ’", enName: "Fried Chicken Fillet", emoji: "ğŸ—", desc: "æ¯”è‡‰é‚„å¤§ï¼Œç½ªæƒ¡æ„Ÿæ»¿æ»¿ï¼" },
    { name: "ç‰›è‚‰éºµ", enName: "Beef Noodle Soup", emoji: "ğŸœ", desc: "æ¹¯é ­æ¿ƒéƒï¼Œè‚‰å¡Šåšå¯¦ï¼" },
    { name: "å°ç± åŒ…", enName: "Xiao Long Bao", emoji: "ğŸ¥Ÿ", desc: "çš®è–„é¤¡å¤šï¼Œå°å¿ƒç‡™å£ï¼" },
    { name: "èšµä»”ç…", enName: "Oyster Omelet", emoji: "ğŸ¦ª", desc: "é®®ç”œè‚¥ç¾ï¼Œé†¬æ±æ˜¯éˆé­‚ï¼" },
    { name: "èŠ’æœå†°", enName: "Mango Shaved Ice", emoji: "ğŸ¥­", desc: "å¤æ—¥å¿…å‚™ï¼Œé…¸ç”œæ¶ˆæš‘ï¼" },
    { name: "å¤§è…¸åŒ…å°è…¸", enName: "Taiwanese Sausage", emoji: "ğŸŒ­", desc: "å°å¼ç†±ç‹—ï¼Œç‚­ç«é¦™æ°£ï¼" },
    { name: "è”¥æŠ“é¤…", enName: "Scallion Pancake", emoji: "ğŸ¥", desc: "å±¤æ¬¡åˆ†æ˜ï¼Œé…¥è„†æ‰æ¸£ï¼" },
    { name: "æ»·å‘³", enName: "Braised Dishes", emoji: "ğŸ¥š", desc: "å®µå¤œé¦–é¸ï¼Œæ¨£æ¨£å…¥å‘³ï¼" },
    { name: "é¹½é…¥é›", enName: "Popcorn Chicken", emoji: "ğŸ–", desc: "ä¹å±¤å¡”é¦™ï¼Œä¸€å£æ¥ä¸€å£ï¼" },
    { name: "é³³æ¢¨é…¥", enName: "Pineapple Cake", emoji: "ğŸ", desc: "é‡‘é»ƒå…§é¤¡ï¼Œä¼´æ‰‹ç¦®ä¹‹ç‹ï¼" },
    { name: "è±†èŠ±", enName: "Tofu Pudding", emoji: "ğŸ®", desc: "ç¶¿å¯†æ»‘é †ï¼ŒèŠ±ç”Ÿè»Ÿçˆ›ï¼" },
    { name: "è±¬è¡€ç³•", enName: "Pig Blood Cake", emoji: "ğŸ¢", desc: "å£æ„ŸQç³¯ï¼Œæ²¾èŠ±ç”Ÿç²‰çµ•é…ï¼" },
    { name: "åˆˆåŒ…", enName: "Gua Bao", emoji: "ğŸ”", desc: "å°å¼æ¼¢å ¡ï¼Œè‚¥è‚‰åŠ èŠ±ç”Ÿç²‰ï¼" },
    { name: "åœ°ç“œçƒ", enName: "Sweet Potato Balls", emoji: "ğŸ ", desc: "å¤–é…¥å…§ç©ºï¼Œå¤œå¸‚å¿…è²·ï¼" },
    { name: "æ½¤é¤…", enName: "Popiah", emoji: "ğŸŒ¯", desc: "æ¸…çˆ½è±å¯Œï¼Œä¸€æ²æ»¿è¶³ï¼" },
    { name: "æ“”ä»”éºµ", enName: "Danzai Noodles", emoji: "ğŸœ", desc: "è‚‰ç‡¥è¦æ¹¯ï¼Œç™¾å¹´æ»‹å‘³ï¼" },
    { name: "ç¢—ç²¿", enName: "Salty Rice Pudding", emoji: "ğŸ¥£", desc: "ç±³é¦™æ¿ƒéƒï¼Œé†¬æ²¹è†é¹¹ç”œï¼" },
    { name: "éµè›‹", enName: "Iron Egg", emoji: "ğŸŒ‘", desc: "è¶Šåš¼è¶Šé¦™ï¼Œæ·¡æ°´åç”¢ï¼" },
    { name: "å¤ªé™½é¤…", enName: "Sun Cake", emoji: "â˜€ï¸", desc: "é…¥çš®éº¥èŠ½ï¼Œå°ä¸­é©•å‚²ï¼" },
    { name: "æ£ºææ¿", enName: "Coffin Bread", emoji: "ğŸ", desc: "ç‚¸åå¸è£æ¿ƒæ¹¯ï¼Œå£æ„Ÿè±å¯Œï¼" },
    { name: "è‚‰åœ“", enName: "Ba Wan", emoji: "ğŸ˜", desc: "Qçš®è‚‰é¤¡ï¼Œç‚¸è’¸çš†å®œï¼" },
    { name: "è–‘æ¯é´¨", enName: "Ginger Duck", emoji: "ğŸ¥˜", desc: "å†¬æ—¥é€²è£œï¼Œå…¨èº«æš–å‘¼å‘¼ï¼" },
    { name: "ç¾Šè‚‰çˆ", enName: "Mutton Hot Pot", emoji: "ğŸ²", desc: "è—¥è†³æ¹¯é ­ï¼Œæº«æ½¤æ»‹è£œï¼" },
    { name: "å‰‰å†°", enName: "Shaved Ice", emoji: "ğŸ§", desc: "é…æ–™è‡ªé¸ï¼Œæ·‹ä¸Šé»‘ç³–æ°´ï¼" },
    { name: "æœ¨ç“œç‰›å¥¶", enName: "Papaya Milk", emoji: "ğŸ¥›", desc: "æ¿ƒé†‡é¦™æ»‘ï¼Œå®Œç¾æ¯”ä¾‹ï¼" },
    { name: "é›è‚‰é£¯", enName: "Turkey Rice", emoji: "ğŸš", desc: "é›æ²¹æ‹Œé£¯ï¼Œç°¡å–®ç¾å‘³ï¼" },
    { name: "èƒ¡æ¤’é¤…", enName: "Pepper Bun", emoji: "ğŸ¥¯", desc: "ç‚­çƒ¤ç„¦é¦™ï¼Œè‚‰æ±çˆ†ç™¼ï¼" },
    { name: "è›‹é¤…", enName: "Egg Pancake Roll", emoji: "ğŸ³", desc: "æ—©é¤ç¶“å…¸ï¼Œå£å‘³ç™¾è®Šï¼" },
    { name: "éºµç·š", enName: "Oyster Vermicelli", emoji: "ğŸœ", desc: "å¤§è…¸èšµä»”ï¼Œå‹¾èŠ¡æ»‘é †ï¼" }
  ];

  readonly auntieQuotes = {
    start: ["ä¾†ä¾†ä¾†ï¼é€™å…©æ¨£ä½ é¸å“ªä¸€æ¨£ï¼Ÿé˜¿å§¨è«‹å®¢...æ‰æ€ªï¼", "å“å”·ï¼é€™å…©å€‹éƒ½å¾ˆå²å®³æï¼", "é¸ä¸å‡ºä¾†å—ï¼Ÿé–‰è‘—çœ¼ç›æŒ‰ä¸‹å»å•¦ï¼"],
    hover: ["é€™å€‹å¥½ï¼é€™å€‹çœŸçš„å¥½ï¼", "é¸æˆ‘ï¼æˆ‘è¶…å¤šæ±çš„ï¼", "ä½ çœ‹é‚£å€‹çš®ï¼Œå˜–å˜–å˜–ï¼", "é˜¿å§¨è·Ÿä½ èªªï¼Œé€™å€‹æ˜¯æ‹›ç‰Œï¼"],
    click: ["å¥½çœ¼å…‰ï¼é˜¿å§¨ä¹Ÿå–œæ­¡é€™å€‹ï¼", "çœŸçš„å‡çš„ï¼Ÿä½ ç«Ÿç„¶é¸é€™å€‹ï¼", "æ²’éŒ¯ï¼é€™å€‹æ‰æ˜¯ç‹é“ï¼"]
  };

  // --- State Signals ---
  currentRoundCandidates = signal<Food[]>([]);
  nextRoundCandidates = signal<Food[]>([]);
  currentPairIndex = signal<number>(0);
  roundName = signal<string>("32 å¼·è³½");
  agentText = signal<string>("");
  agentPop = signal<boolean>(false);
  
  // Track failed images
  imageErrors = signal<Set<string>>(new Set());
  
  // Animation State: 'idle' | 'left-win' | 'right-win'
  animState = 'idle';
  isAnimating = false;
  
  // Champion
  champion: Food | null = null;
  
  // Dots Helper
  get dotsArray() {
    return new Array(Math.ceil(this.currentRoundCandidates().length / 2));
  }

  // Computed Values for current pair
  currentLeft = computed(() => this.currentRoundCandidates()[this.currentPairIndex()]);
  currentRight = computed(() => this.currentRoundCandidates()[this.currentPairIndex() + 1]);

  // Audio Context
  private audioCtx: AudioContext | null = null;

  ngOnInit() {
    this.initGame();
  }

  // Helper to generate Real Food URL from Bing Thumbnail Search
  // é€™æ˜¯ç›®å‰æœ€ç©©å®šèƒ½æŠ“åˆ°ã€ŒçœŸå¯¦ç¶²è·¯åœ–ç‰‡ã€çš„æ–¹æ³•
  // ä½¿ç”¨ Bing çš„ç¸®åœ–æœå‹™ï¼Œæœå°‹ã€Œé£Ÿç‰©åç¨± + å°ç£ç¾é£Ÿã€
  getImageUrl(food: Food): string {
    // ä½¿ç”¨ä¸­æ–‡åç¨±æœå°‹æœ€æº–ç¢º
    const query = `${food.name} å°ç£ç¾é£Ÿ`; 
    // tse2.mm.bing.net æ˜¯ä¸€å€‹ç©©å®šçš„ç¸®åœ–æœå‹™
    // c=7: è£åˆ‡ä¸¦ç¸®æ”¾ (Smart crop)
    // rs=1: ç¸®æ”¾
    return `https://tse2.mm.bing.net/th?q=${encodeURIComponent(query)}&w=500&h=500&c=7&rs=1`;
  }
  
  // Handle image error
  handleImageError(foodName: string) {
    console.log(`Image failed for: ${foodName}, falling back to emoji.`);
    this.imageErrors.update(set => {
      const newSet = new Set(set);
      newSet.add(foodName);
      return newSet;
    });
  }

  hasImageError(foodName: string): boolean {
    return this.imageErrors().has(foodName);
  }

  initGame() {
    // Shuffle
    const shuffled = [...this.allFoods].sort(() => Math.random() - 0.5).slice(0, 32);
    this.currentRoundCandidates.set(shuffled);
    this.nextRoundCandidates.set([]);
    this.currentPairIndex.set(0);
    this.roundName.set("32 å¼·è³½");
    this.champion = null;
    this.animState = 'idle';
    this.isAnimating = false;
    this.imageErrors.set(new Set()); // Reset errors
    
    this.updateAgent(this.getRandomQuote(this.auntieQuotes.start));
  }

  // Interaction Logic
  selectWinner(side: 'left' | 'right') {
    if (this.isAnimating) return;
    this.isAnimating = true;
    this.playSound('select');

    // Set animation state
    this.animState = side === 'left' ? 'left-win' : 'right-win';

    // Agent Feedback
    this.updateAgent(this.getRandomQuote(this.auntieQuotes.click));

    // Determine winner logic
    const winnerItem = side === 'left' ? this.currentLeft() : this.currentRight();
    this.nextRoundCandidates.update(arr => [...arr, winnerItem]);

    // Delay for animation
    setTimeout(() => {
      this.advancePair();
    }, 800);
  }

  advancePair() {
    this.animState = 'idle';
    this.isAnimating = false;

    const nextIndex = this.currentPairIndex() + 2;

    if (nextIndex >= this.currentRoundCandidates().length) {
      this.advanceRound();
    } else {
      this.currentPairIndex.set(nextIndex);
    }
  }

  advanceRound() {
    const survivors = this.nextRoundCandidates();
    
    if (survivors.length === 1) {
      // We have a winner!
      this.champion = survivors[0];
      return;
    }

    // Next Round Setup
    this.currentRoundCandidates.set(survivors);
    this.nextRoundCandidates.set([]);
    this.currentPairIndex.set(0);

    // Update Round Name
    const count = survivors.length;
    let name = "";
    if (count === 16) name = "16 å¼·æ¿€æˆ°";
    else if (count === 8) name = "8 å¼·çˆ­éœ¸";
    else if (count === 4) name = "4 å¼·æº–æ±ºè³½";
    else if (count === 2) name = "å† äºè»æ±ºè³½";
    this.roundName.set(name);

    this.updateAgent(`æ­å–œé€²å…¥ ${name}ï¼è¶Šä¾†è¶Šé›£é¸äº†å°å§ï¼Ÿ`);
  }

  restartGame() {
    this.initGame();
  }

  onHover(side: 'left' | 'right') {
    if (this.isAnimating) return;
    this.playSound('hover');
    
    const item = side === 'left' ? this.currentLeft() : this.currentRight();
    const quote = this.getRandomQuote(this.auntieQuotes.hover);
    this.updateAgent(`${item.desc} ${quote}`);
  }

  // Agent Helper
  updateAgent(text: string) {
    this.agentPop.set(true);
    setTimeout(() => this.agentPop.set(false), 200);
    this.agentText.set(text);
  }

  getRandomQuote(arr: string[]): string {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // Audio Logic (Synthetic sounds)
  playSound(type: 'hover' | 'select') {
    try {
      if (!this.audioCtx) {
        this.audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
      }
      if (this.audioCtx.state === 'suspended') {
        this.audioCtx.resume();
      }

      const oscillator = this.audioCtx.createOscillator();
      const gainNode = this.audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(this.audioCtx.destination);

      const now = this.audioCtx.currentTime;

      if (type === 'hover') {
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(400, now);
        oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gainNode.gain.setValueAtTime(0.05, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        oscillator.start(now);
        oscillator.stop(now + 0.1);
      } else if (type === 'select') {
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(300, now);
        oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        oscillator.start(now);
        oscillator.stop(now + 0.3);
      }
    } catch (e) {
      console.warn('Audio play failed', e);
    }
  }
}